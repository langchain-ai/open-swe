---
title: "Authentication"
description: "How authentication works in Open SWE"
---

Open SWE implements a comprehensive authentication system that secures both client-side interactions and server-side operations. The authentication flow supports both GitHub and GitLab OAuth for user authentication, encrypted token handling, and multi-layered security for LangGraph server requests.

## Git Provider OAuth Authentication

Open SWE supports OAuth authentication for both GitHub and GitLab, providing secure access to user accounts and repository permissions.

### Authentication Flow

- **Unauthenticated users** can choose to authenticate with GitHub or GitLab OAuth
- **Authenticated users** are redirected directly to the chat interface
- **Settings management** is available at `/settings` for managing authentication
- **Multiple providers** - Open SWE supports both GitHub and GitLab simultaneously

<Note>
  OAuth authentication provides the foundation for all user interactions,
  enabling Open SWE to access repositories and perform actions on behalf of
  authenticated users. Users can authenticate with either GitHub or GitLab
  depending on which provider they configured during setup.
</Note>

### Provider Setup

For detailed instructions on configuring OAuth authentication:
- **[GitLab Setup Guide](/labs/swe/setup/gitlab)** - Complete GitLab OAuth configuration
- **[Development Setup](/labs/swe/setup/development)** - GitHub App creation and OAuth setup

## LangGraph Server Authentication

All requests to the LangGraph server are authenticated through a sophisticated proxy system that ensures secure communication between the web interface and the agent backend.

### Proxy Route Architecture

The Next.js application includes a proxy route (`apps/web/src/app/api/[..._path]/route.ts`) that acts as an intermediary for all LangGraph server requests. This proxy uses the [`langgraph-nextjs-api-passthrough`](https://www.npmjs.com/package/langgraph-nextjs-api-passthrough) package to handle request forwarding with enhanced security.

<Tip>
  The proxy route ensures that sensitive authentication tokens never reach the
  client directly, maintaining security while enabling seamless communication
  with the LangGraph server.
</Tip>

## Simple API Key (Bearer) Authentication

For local development and scripted access, the LangGraph server also supports a simple bearer token scheme. When a request includes an `Authorization: Bearer <token>` header, this path is used and the rest of the auth flow is skipped.

### Setup (development)

- **Generate a token** (32+ bytes, URL-safe):
  - OpenSSL: `openssl rand -hex 32`
- **Add to your `.env` for the LangGraph server**:

```bash
API_BEARER_TOKEN=<your-generated-token>
```

- For multiple/rotation: use comma-separated tokens

```bash
API_BEARER_TOKENS=<token1>,<token2>,<token3>
```

Restart the LangGraph server after updating environment variables.

### Usage

```typescript
import { Client } from "@langchain/langgraph-sdk";

const client = new Client({
  apiUrl: process.env.LANGGRAPH_API_URL,
  defaultHeaders: {
    authorization: `Bearer ${process.env.API_BEARER_TOKEN}`,
  },
});
```

### Notes

- **Precedence**: If the `Authorization` header is present, bearer auth is used; otherwise the existing GitHub-based flow applies.
- **Rotation**: Add a new token to `API_BEARER_TOKENS`, deploy/restart, migrate clients, then remove old tokens and redeploy.
- **Scope**: All bearer tokens currently map to the same internal identity and permissions. If you need per-token identities/quotas, reach out to adjust the configuration.

### Header Injection System

The proxy route automatically injects encrypted headers into each request based on the authenticated provider:

#### GitHub Authentication Headers

- **`x-github-access-token`** - User's GitHub access token for user-specific actions (creating issues, comments)
- **`x-github-installation-token`** - GitHub App installation token for app-level actions (commits, pull requests)
- **`x-github-installation-name`** - Installation name (username or organization name)
- **`x-github-installation-id`** - GitHub App installation ID

#### GitLab Authentication Headers

- **`x-gitlab-access-token`** - User's GitLab access token for API operations
- **`x-gitlab-base-url`** - GitLab instance URL (e.g., `https://gitlab.com` or self-hosted URL)
- **`x-git-provider-type`** - Set to `"gitlab"` to indicate GitLab provider

#### Shared Headers

- **`x-git-provider-type`** - Either `"github"` or `"gitlab"` to indicate the authenticated provider

<Note>
  All headers are prefixed with `x-` to ensure they're included in LangGraph run
  configurations, making them accessible during execution while maintaining
  security through encryption. The provider-specific headers are only injected
  when the corresponding provider is authenticated.
</Note>

### Token Encryption

Open SWE implements AES-256-GCM encryption for all secrets passed to the LangGraph server to prevent exposure in:

- LangSmith trace metadata
- Run configurations
- Potential unauthorized access scenarios

The encryption process uses the `SECRETS_ENCRYPTION_KEY` environment variable and includes:

- **Initialization Vector (IV)** for unique encryption per token
- **Authentication Tag** for data integrity verification
- **Base64 encoding** for safe transport

<Tip>
  The same encryption key must be configured in both the web application and
  LangGraph agent for proper token decryption.
</Tip>

## Authentication Middleware

The LangGraph server implements comprehensive authentication middleware (`apps/open-swe/src/security/auth.ts`) that validates all incoming requests.

### Webhook Authentication

The middleware supports webhook authentication for both GitHub and GitLab:

#### GitHub Webhooks

Detected by the `X-Hub-Signature-256` header:

1. **HMAC signature verification** using the configured webhook secret (`GITHUB_WEBHOOK_SECRET`)
2. **Automatic authorization** for valid webhook signatures
3. **Separate user verification** in subsequent run creation requests

#### GitLab Webhooks

Detected by the `X-Gitlab-Token` header:

1. **Token-based verification** using the configured webhook token (`GITLAB_WEBHOOK_TOKEN`)
2. **Automatic authorization** for matching tokens
3. **Separate user verification** in subsequent run creation requests

<Note>
  Webhook authentication is handled separately from user authentication to
  enable automated issue/MR processing while maintaining security. Both
  providers use different verification mechanisms to ensure webhook authenticity.
</Note>

### Standard Request Authentication

For non-webhook requests, the middleware validates provider-specific headers:

#### GitHub Required Headers

- **Installation name** (`x-github-installation-name`)
- **Installation token** (`x-github-installation-token`)
- **Installation ID** (`x-github-installation-id`)

#### GitLab Required Headers

- **Access token** (`x-gitlab-access-token`)
- **Base URL** (`x-gitlab-base-url`)
- **Provider type** (`x-git-provider-type` set to `"gitlab"`)

Missing required headers for the authenticated provider results in a 401 Unauthorized error.

#### User Verification Process

The middleware supports two authentication paths for both providers:

**Web Application Requests:**

- Uses encrypted access tokens (`x-github-access-token` or `x-gitlab-access-token`)
- Verifies user identity through the provider's API
- Extracts user ID and login from token

**Webhook-Generated Requests:**

- Uses explicit user headers from webhook payload
- Validates user ID and login against provider tokens
- Ensures webhook-created runs are properly attributed

### Identity and Permissions

Upon successful authentication, the middleware returns an identity object containing:

- **User ID** for resource ownership verification
- **Display name** (provider username/login)
- **Provider context** (installation name for GitHub, base URL for GitLab)
- **Comprehensive permissions** for LangGraph operations

<Tip>
  The user ID serves as the primary identifier for resource access control,
  ensuring users can only access their own threads, runs, and assistants
  regardless of which Git provider they're using.
</Tip>

## Resource Access Control

Open SWE implements fine-grained access control for all LangGraph resources:

### Metadata-Based Ownership

- **Create operations** automatically add user ID to resource metadata
- **Read/Update/Delete operations** verify user ID matches resource owner
- **Search operations** filter results by user ownership

## Token Access During Execution

During LangGraph run execution, encrypted tokens are accessible through the run's configurable field:

1. **Token extraction** from run configuration
2. **Decryption** using the shared encryption key
3. **Provider-specific action execution**:
   - **GitHub**: Creating issues/PRs, commits, comments via GitHub App token
   - **GitLab**: Creating issues/MRs, commits, notes via Personal Access Token

<Note>
  This design ensures tokens remain encrypted in storage and traces while being
  available for necessary Git provider operations during run execution. The
  provider abstraction layer handles the differences between GitHub and GitLab
  automatically.
</Note>

<Tip>
  Always ensure the `SECRETS_ENCRYPTION_KEY` environment variable is identical
  between your web application and LangGraph agent deployments, regardless of
  which Git provider(s) you're using.
</Tip>
