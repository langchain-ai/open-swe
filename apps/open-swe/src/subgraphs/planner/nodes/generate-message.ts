import { loadModel, Task } from "../../../utils/load-model.js";
import { shellTool } from "../../../tools/index.js";
import { PlannerGraphState, PlannerGraphUpdate } from "../types.js";
import { GraphConfig } from "@open-swe/shared/open-swe/types";
import { createLogger, LogLevel } from "../../../utils/logger.js";
import { getMessageContentString } from "@open-swe/shared/messages";
import { getUserRequest } from "../../../utils/user-request.js";
import { isHumanMessage } from "@langchain/core/messages";
import { formatFollowupMessagePrompt } from "../utils/followup-prompt.js";
import { getRepoAbsolutePath } from "../../../utils/git.js";

const logger = createLogger(LogLevel.INFO, "GeneratePlanningMessageNode");

const systemPrompt = `You are operating as a terminal-based agentic coding assistant built by LangChain. It wraps LLM models to enable natural language interaction with a local codebase. You are expected to be precise, safe, and helpful.
{FOLLOWUP_MESSAGE_PROMPT}

You MUST adhere to the following criteria when gathering context for the plan:
- Your ONLY job is to gather context for the plan.
  - You are NOT allowed to take any write/update actions, instead you must only take read actions to gather context.
- Ensure each tool call you generate is of an extremely high quality, and targeted to aid in generating a plan. 
- Always use \`rg\` instead of \`grep/ls -R\` because it is much faster and respects gitignore.
  - Always use glob patterns when searching with \`rg\` for specific file types. For example, to search for all TSX files, use \`rg -i star -g **/*.tsx project-directory/\`. This is because \`rg\` does not have built in file types for every language.
- When calling the \`shell\` tool it is incredibly important your commands are properly formatted. You should ALWAYS remember to include proper quotes, and ensure the command is formatted correctly.
- If you determine you've gathered enough context to generate a plan, simply reply with 'done' and do NOT call any tools.
- Not generating a tool call will be interpreted as an indication that you've gathered enough context to generate a plan.
- The repo is already cloned, and located inside your current working directory: {CURRENT_WORKING_DIRECTORY}

Below is an up to date tree of the codebase (going 3 levels deep). You should assume this is always up to date.
It was generated by using the \`tree\` command, passing in the gitignore file to ignore files and directories you should not have access to (\`git ls-files | tree --fromfile -L 3\`).
It is always executed inside the repo directory (also your current working directory): {CURRENT_WORKING_DIRECTORY}
{CODEBASE_TREE}

Your current working directory is: {CURRENT_WORKING_DIRECTORY}

The user's request is the first user message in the conversation below. Ensure you generate your plan in accordance with the user's request.
`;

function formatSystemPrompt(state: PlannerGraphState): string {
  // It's a followup if there's more than one human message.
  const isFollowup = state.internalMessages.filter(isHumanMessage).length > 1;

  return systemPrompt
    .replace(
      "{FOLLOWUP_MESSAGE_PROMPT}",
      isFollowup ? formatFollowupMessagePrompt(state.plan) : "",
    )
    .replaceAll(
      "{CODEBASE_TREE}",
      `<codebase-tree>\n${state.codebaseTree || "No codebase tree generated yet."}\n</codebase-tree>`,
    )
    .replaceAll("{CURRENT_WORKING_DIRECTORY}", getRepoAbsolutePath(state.targetRepository));
}

export async function generateAction(
  state: PlannerGraphState,
  config: GraphConfig,
): Promise<PlannerGraphUpdate> {
  const model = await loadModel(config, Task.ACTION_GENERATOR);
  const tools = [shellTool];
  const modelWithTools = model.bindTools(tools, {
    tool_choice: "auto",
    parallel_tool_calls: false,
  });

  const userRequest = getUserRequest(state.internalMessages, {
    returnFullMessage: true,
  });

  const response = await modelWithTools
    .withConfig({ tags: ["nostream"] })
    .invoke([
      {
        role: "system",
        content: formatSystemPrompt(state),
      },
      userRequest,
      ...state.plannerMessages,
    ]);

  logger.info("Generated planning message", {
    ...(getMessageContentString(response.content) && {
      content: getMessageContentString(response.content),
    }),
    ...(response.tool_calls?.[0] && {
      name: response.tool_calls?.[0].name,
      args: response.tool_calls?.[0].args,
    }),
  });

  return {
    messages: [response],
    plannerMessages: [response],
  };
}
